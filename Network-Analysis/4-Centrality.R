#####################
# LAB 4: Centrality #
#####################


# NOTE: if you have trouble because some packages are not installed, 
# see lab 1 for instructions on how to install all necessary packages.


#############################################################
# 
# Lab 4 
#
# The purpose of this lab is to acquire centrality measures, 
# to determine how they are interrelated, and to discern 
# what they mean. 
#
##############################################################
 

###
# 1. SETUP 
###
library(igraph)


###
# 2. LOAD DATA
###

# This lab uses SSL.dat (social interaction) and TSL.dat (task 
# interaction) from the S641 Semester 1 class in student_nets.
# The class is a biology 2 class at a public high school.

# load data:
data(studentnets.S641, package = "NetData")

# Reduce to non-zero edges and build a graph object
s641_full_nonzero_edges <- subset(s641_full_data_frame, (social_tie > 0 | task_tie > 0))
head(s641_full_nonzero_edges)

s641_full <- graph.data.frame(s641_full_nonzero_edges) 
summary(s641_full)

# Create sub-graphs based on edge attributes and remove isolates
s641_social <- delete.edges(s641_full, E(s641_full)[get.edge.attribute(s641_full,name = "social_tie")==0])
s641_social <- delete.vertices(s641_social, V(s641_social)[degree(s641_social)==0])
summary(s641_social)

s641_task <- delete.edges(s641_full, E(s641_full)[get.edge.attribute(s641_full,name = "task_tie")==0])
s641_task <- delete.vertices(s641_task, V(s641_task)[degree(s641_task)==0])
summary(s641_task)

# Look at the plots for each sub-graph
social_layout <- layout.fruchterman.reingold(s641_social)
plot(s641_social, layout=social_layout, edge.arrow.size=.5)

# Note: click on the graph and then use the drop down menu to 
# save any plot you like -- it will save as a pdf. 

task_layout <- layout.fruchterman.reingold(s641_task)
plot(s641_task, layout=task_layout, edge.arrow.size=.5)

# Question #1 - what can you say about network centralization from these graphs?


###
# 3. CALCULATE CENTRALITY MEASURES FOR SOCIAL
###

# Indegree centrality measures how many people direct social 
# talk to the individual.
indegree_social <- degree(s641_social, mode='in')
indegree_social

# Outdegree centrality measures how many people the actor directs 
# social talk to. 
outdegree_social <- degree(s641_social, mode='out')
outdegree_social

# Closeness is the mean geodesic distance between a given node and
# all other nodes with paths from the given node to the other
# node. This is close to being the mean shortest path, but 
# geodesic distances give higher values for more central nodes.
#
# In a directed network, we can think of in-closeness centrality
# as the average number of steps one would have to go through to
# get TO a given node FROM all other reachable nodes in the
# network. Out-closeness centrality, not surprisingly, measures
# the same thing with the directionality reversed.

# In-closeness centrality
incloseness_social <- closeness(s641_social, mode='in')
incloseness_social

# Out-closeness
outcloseness_social <- closeness(s641_social, mode='out')
outcloseness_social

# Betweenness centrality measures the number of shortest paths
# going through a specific vertex; it is returned by the 
# betweenness() function. (Recall that in the previous lab we used 
# a related measure called edge betweenness, which is returned by
# the edge.betweenness() function.)
betweenness_social <- betweenness(s641_social)
betweenness_social

# Eigenvector centrality gives greater weight to a node the more 
# it is connected to other highly connected nodes. A node
# connected to five high-scoring nodes will have higher 
# eigenvector centrality than a node connected to five low-scoring
# nodes. Thus, it is often interpreted as measuring a node's
# network importance.
# 
# In directed networks, there are 'In' and 'Out' versions. In
# information flow studies, for instance, In-Eigenvector scores
# would reflect which nodes are high on receiving information,
# while Out-Eigenvector scores would reflect which nodes are high
# on broadcasting information.
#
# For these data, we will simply symmetrize to generate an 
# undirected eigenvector centrality score.
#
# Note that, unlike the other centrality measures, evcent() 
# returns a complex object rather than a simple vector. Thus, 
# we need to first get the evcent() output and then select the 
# eigenvector scores from it.
s641_social_undirected <- as.undirected(s641_social, mode='collapse')
ev_obj_social <- evcent(s641_social_undirected)
eigen_social <- ev_obj_social$vector
eigen_social

#####
# Extra Credit - what code would you write in R 
# to get the directed versions of eigenvector centrality?
#####

# To get the summary table, we'll construct a data frame with 
# the vertices as rows and the centrality scores as columns.
# 
# Note that the vertex IDs are NOT the same as the first column
# of row numbers. This is because we previously removed isolates.
central_social <- data.frame(V(s641_social)$name, indegree_social, outdegree_social, incloseness_social, outcloseness_social, betweenness_social, eigen_social)
central_social 

# Now we'll examine the table to find the most central actors 
# according to the different measures we have. When looking at
# each of these measures, it's a good idea to have your plot on
# hand so you can sanity-check the results.
plot(s641_social, vertex.size=10, vertex.label=V(s641_social)$name,
edge.arrow.size = 0.5, layout=layout.fruchterman.reingold,main='Classroom S641 Social Talk')

# Show table sorted by decreasing indegree. The order() function 
# returns a vector in ascending order; the minus sign flips it 
# to be descending order. Top actors are 18, 22 and 16.
central_social[order(-central_social$indegree_social),] 

# Outdegree: 22, 18 and 19.
central_social[order(-central_social$outdegree_social),] 

# In-closeness: 11, 15 and 18. 
# NOTE: For some reason, this operation returns strange values;
# a visual inspection of the plot suggests that 11, 15, and 18
# are not central actors at all. This could be a bug.
central_social[order(-central_social$incloseness_social),] 

# Out-closeness: 22, 16, and 19
central_social[order(-central_social$outcloseness_social),] 

# Eigenvector: 18, 19, and 16
central_social[order(-central_social$eigen_social),] 

# let's make a plot or two with these summary statistics

# To visualize these data, we can create a barplot for each
# centrality measure. In all cases, the y-axis is the value of
# each category and the x-axis is the node number. 
barplot(central_social$indegree_social, names.arg=central_social$V.s641_social..name)
barplot(central_social$outdegree_social, names.arg=central_social$V.s641_social..name)
barplot(central_social$incloseness_social, names.arg=central_social$V.s641_social..name)
barplot(central_social$outcloseness_social, names.arg=central_social$V.s641_social..name)
barplot(central_social$betweenness_social, names.arg=central_social$V.s641_social..name)
barplot(central_social$eigen_social, names.arg=central_social$V.s641_social..name)

# Question #2 - What can we say about the social actors if we compare the bar plots? 
# Who seems to run the show in sociable affairs? Who seems to bridge sociable conversations? 


###
# 4. CORRELATIONS BETWEEN CENTRALITY MEASURES
###

# Now we'll compute correlations betwee the columns to determine
# how closely these measures of centrality are interrelated. 

# Generate a table of pairwise correlations.
cor(central_social[,2:7])

# INTERPRETATION:
#
# Indegree and outdegree are very closely correlated (rho = 0.95),
# indicating that social talk with others is reciprocated (i.e.,
# if you talk to others, they tend to talk back to you).
# 
# The same is not true of incloseness and outcloseness (rho = 
# 0.38), indicating that the closeness calculated from inbound
# paths is not strongly associated with with closeness from
# outbound paths.
# 
# In- and out-degree are highly correlated with eigenvector
# centrality, indicating that the students that talk the most to
# others (or, relatedly, are talked to the most by others) are
# also the ones that are connected to other highly connected
# students -- possibly indicating high density cliques around
# these individuals.
# 
# Betweennes shows the highest corelation with outdegree, follwed
# by indegree. In the case of this particular network, it seems
# that the individuals that talk to the most others are the
# likeliest to serve as bridges between the particular cliques
# (see, e.g., 22 in the plot).


###
# 5. REPEAT FOR TASK TALK
###

# Indegree
# We should have 20 entries, indicating 2 isolates. 
indegree_task <- degree(s641_task, mode='in')
indegree_task

# Outdegree
outdegree_task <- degree(s641_task, mode='out')
outdegree_task

# In-closeness
incloseness_task <- closeness(s641_task, mode='in')
incloseness_task

# Out-closeness
outcloseness_task <- closeness(s641_task, mode='out')
outcloseness_task

# Betweenness. Note that the closeness measures arent very high
# for node 22, but the betweenness is off the charts.
betweenness_task <- betweenness(s641_task)
betweenness_task

# Eigenvector
s641_task_undirected <- as.undirected(s641_task, mode='collapse')
ev_obj_task <- evcent(s641_task_undirected)
eigen_task <-ev_obj_task$vector
eigen_task

# Generate a data frame with all centrality values
central_task <- data.frame(V(s641_task)$name, indegree_task, outdegree_task, incloseness_task, outcloseness_task, betweenness_task, eigen_task)
central_task

# In-degree: 22, 18 and 17
central_task[order(-central_task$indegree_task),] 

# Outdegree: 22, 18 and 17
central_task[order(-central_task$outdegree_task),] 

# Incloseness: 22, 18 and 17
central_task[order(-central_task$incloseness_task),] 

# Outcloseness: 22, 18 and 17
central_task[order(-central_task$outcloseness_task),] 

# Eigenvector: 22, 18 and 17
central_task[order(-central_task$eigen_task),] 

# Look at barplots
barplot(central_task$indegree_task, names.arg=central_task$V.s641_task..name)
barplot(central_task$outdegree_task, names.arg=central_task$V.s641_task..name)
barplot(central_task$incloseness_task, names.arg=central_task$V.s641_task..name)
barplot(central_task$outcloseness_task, names.arg=central_task$V.s641_task..name)
barplot(central_task$betweenness_task, names.arg=central_task$V.s641_task..name)
barplot(central_task$eigen_task, names.arg=central_task$V.s641_task..name)

# Question #3 - What can we say about the social actors if we compare the bar plots? 
# Who seems to run the show in task affairs? Who seems to bridge task conversations? 


###
# 6. TASK/SOCIAL CORRELATIONS 
###

# Note that in order to do this, we need to either have no missing
# data or use pairwise complete observations.
#
# It would be nice if the centrality functions padded N/A or zero
# data for the isolates, because then the dimensions of the two
# matrices would be compatible. But right now we have 19 nodes for 
# social interaction and 20 nodes for task interaction. So first 
# we have to do some hacky R stuff to make them both have 22
# nodes.

# First, we'll extract the node names from the SSL data, using
# levels() because it's a factor and converting it to numbers so
# we can match with the TSL data. Then we'll repeat for TSL.
connectednodes_social = as.numeric(levels(central_social$V.s641_social..name))[central_social$V.s641_social..name]
connectednodes_task = as.numeric(levels(central_task$V.s641_task..name))[central_task$V.s641_task..name]

# Check that we did this correctly: SSL should have 19 nodes, and 
# TSL should have 20 nodes.
length(connectednodes_social) 
length(connectednodes_task) 

# Extract matches for each data set, take that subset and use
# columns 2 through 7 to create the correlation matrix. This 
# computes the correlations based only on the actors in both 
# graphs (18 in total).
cor(central_social[which(connectednodes_social %in% connectednodes_task),2:7], central_task[which(connectednodes_task %in% connectednodes_social),2:7])


# INTERPRETATION:
#
# eigen_task is correlated with betweenness_social (rho=0.83) and
# outdegree (rho=0.82), possibly because those who are
# important in talk on tasks also serve as bridges for talk on
# social issues and have many outbound ties.
#
# indegree_task and betweenness_social (rho=0.88), and
# outdegree_task and betweenness_social (rho=0.88) are correlated,
# possibly because the number of indegree and outdegree ties a
# node has with respect to task talk, the more they serve as a
# bridge on social talk.
#
# incloseness_task and incloseness_social (rho=0.86) are
# correlated, meaning that those who serve in shortest parths past
# on inbound ties are equivalent for both social talk and task
# talk, which seems to make sense given the betweenness
# correlations with network importance and degree between task and
# social talk more interpretations are possible as well.

# Question #4 - What can we infer about s641 from these results? 
# What sort of substantive story can we derive from it?
